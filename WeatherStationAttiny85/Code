/*
Code assembled by Tim Motis, much of which is adapted from that by Quintans (2015):

  Quintans, DJ 2015. Sneesl: An Arduino-based data-logger for rain collectors. Microprocessor software. 
  https://github.com/DesiQuintans/sneesl-rain-logger. doi:10.5281/zenodo.1204674 

Code related to debouncing of the reed swtich was sourced from: https://www.youtube.com/watch?v=KHrTqdmYoAk&t=872s 

*/


// LIBRARIES

#include <TinyLoRa.h>
#include <TinyWireM.h>
//#include <avr/wdt.h>  /watchdog
#include <avr/sleep.h>
#include "PinChangeInterrupt.h"
//#include <avr/interrupt.h>

// DEFINITIIONS OF PINS AND VARIABLES

// Rain sensor 
#define rainPin PB4

volatile byte RainFlag = 0; //detect rain interrupt
//#define RainHt 0.03
float RainHt = 0.1;// rain height in cm per tip 
int TipCount = 0;
//unsigned int TipCount = 0; //tipping bucket tip count
volatile unsigned long ContactBounceTimeRain = 0;
//#define Tip 0.02806  //replace this number (cm of rain per tip) based on the area of your rain collector;
                      // Cm of rain per tip = tipping bucket volume in cubic centimeters divided by the 
                      // catchment area, in square cm, of your rain collector 
//Watchdog counter
volatile int watchdog_counter;

//This runs each time the watch dog wakes us up from sleep
ISR(WDT_vect) {
  watchdog_counter++;
}

// #### SETUP ####################################################

/*
    Error codes (Flashing of the LED connected to the ledPin [pin 5 as designated earlier]):
    Fast-fast    RTC couldn't be initialised.
    Fast-slow    SD card couldn't be initialised.
    2 fast 5 Slow All OK, starting to log data.
*/

void setup ()
{
    watchdog_counter = 0;
    pinMode(rainPin, INPUT);
    attachPCINT(digitalPinToPCINT(rainPin), recordTip, FALLING); 
    PCMSK |= (1 << rainPin); //Enable interrupt handler for our chosen interrupt pin (PCINT1/PB1/pin 6)
    GIMSK |= (1 << PCIE); //Enable PCINT in the general interrupt

    //Serial.begin(9600);
   
    TinyWireM.begin();
            
   // ---- LoRa transceiver -------------------
   //replace the LoRa.begin(---E-) argument with your location's frequency 
   //433E6 for Asia
   //866E6 for Europe
   //915E6 for North America
    if (!LoRa.begin(915E6))
    {
      while (1);
    }
    LoRa.setSyncWord(0xF3); // Change sync word (0xF3) to match the receiver to avoid receiving messages from other LoRa transceivers;ranges from 0-0xFF
    delay(500);
    LoRaSend();
    
  setup_watchdog(9); //Wake up after 9 seconds 
}

// #### Main loop ################################################

void loop ()
{  
   sleepNow();  
    // I was woken by either a bucket tip or the watchdog timer. Either way, I'm awake.;
       
   if (RainFlag == 1) {
    TipCount++; // increment the tip counter 
     RainFlag = 0;
       
  }
  
   if(watchdog_counter > 10)  // set to an interval that makes sense 
                              //(1 minute  = 60 seconds/9 seconds per watchdog cycle = 6.7)
  {
    watchdog_counter = 0;
    LoRaSend();
    TipCount = -1;  // on my build, one tip count is added at each watchdog timer interval, here I  subtract it out; if you
                    //are able to solve this with hardware (maybe with minimizing electrical noise via capacitors??) then 
                    //replace "-1" with "0".
  } 
   
}

// FUNCTIONS CALLED IN SETUP OR THE LOOP

void recordTip()
{
    // I heard something. Probably a tip event! (software debouncing--adjust the 225 up or down until the tip counter increases by 1 for every tip)
    if((millis() - ContactBounceTimeRain) > 225); {
    RainFlag = 1;
    ContactBounceTimeRain = millis();
    }
 }

void LoRaSend() {

   float Tips = TipCount/2;
   //float Tips = TipCount;
   float Rain = Tips*RainHt;
   String RainCm = String(Rain, 3); //to show rainfall with 3 numbers after the decimal point
   delay(250);
   //float finalVolt = voltMeasure();
   const int Key = XXXX; //enter a unique 4-digit number that needs to be identical to that used for the receiver
   
   LoRa.beginPacket();
   LoRa.print (Key);
   LoRa.print (":");
   LoRa.print (Tips);
   LoRa.print (":");
   LoRa.print (RainCm);
   LoRa.endPacket(); 
   delay(500);
}

void sleepNow() 
{
  
  // disable ADC
  ADCSRA = 0;
  set_sleep_mode(SLEEP_MODE_IDLE);   // sleep mode is set here

  sleep_enable();          // enables the sleep bit in the mcucr register
  // so sleep is possible. just a safety pin

  sleep_mode();            // here the device is actually put to sleep!!
  // THE PROGRAM CONTINUES FROM HERE AFTER WAKING UP
  sleep_disable();         // first thing after waking from sleep:
  // disable sleep...
}

void setup_watchdog(int timerPrescaler) {

  if (timerPrescaler > 9 ) timerPrescaler = 9; //Correct incoming amount if need be

  byte bb = timerPrescaler & 7; 
  if (timerPrescaler > 7) bb |= (1<<5); //Set the special 5th bit if necessary

  //This order of commands is important and cannot be combined
  MCUSR &= ~(1<<WDRF); //Clear the watch dog reset
  WDTCR |= (1<<WDCE) | (1<<WDE); //Set WD_change enable, set WD enable
  WDTCR = bb; //Set new watchdog timeout value
  WDTCR |= _BV(WDIE); //Set the interrupt enable, this will keep unit from resetting after each int
}
